# Bridge

[Contract bridge](https://en.wikipedia.org/wiki/Contract_bridge) is a
well‐known trick‐taking card game where two partnerships compete each other.

The goal of this project is to produce a lightweight peer‐to‐peer computer
bridge application for social games.

## Features

- GUI for playing social bridge games
- Multiple models of networking: client‐server and peer‐to‐peer
- Cards can be exchanged between peers by mental card game protocol preventing
  cheating (although see section Security for disclaimers)
- Duplicate scoring (but no support for duplicate deals yet…)

## Installing

[CMake](https://cmake.org/) is currently the only supported build system for
the project.

Bridge is written in C++ (backend) and Python (GUI). The backend does all
actual game logic and communicates with the frontend and other peers using TCP
sockets.

The backend needs modern‐ish C++ compiler supporting C++17. The project depends
on
- [ZeroMQ](http://zeromq.org/) for messaging
- [json](https://github.com/nlohmann/json) to serialize and deserialize messages
- [Lua](https://www.lua.org/) for configuration parsing
- [Boost](http://www.boost.org/) for various things.

Optionally [LibTMCG](http://www.nongnu.org/libtmcg/) is used for secure card
exchange.

[Googletest](https://github.com/google/googletest) is used to build unit
tests. As recommended by the maintainers of the project, instead of relying on
any version of googletest found on the local computer, it is downloaded when
required.

To build and run unit tests for the backend

    $ mkdir /the/build/directory
    $ cd /the/build/directory
    $ cmake /the/source/directory
    $ make
    $ make test
    $ make install

## Bridge GUI

Note! I’m in the process of migrating command line arguments into config file
configurations. Inconsistencies may exist.

This repository only contains code for the backend. In order to play bridge,
you’ll also need a frontend. A GUI written in Python can be found in my other
repository at https://github.com/jasujm/bridgegui.

The GUI depends on
[PyQt5](https://www.riverbankcomputing.com/software/pyqt/download5) to provide
the GUI framework and [PyZQM](https://github.com/zeromq/pyzmq) for messaging.

## Building documentation

[Doxygen](http://www.stack.nl/~dimitri/doxygen/) is used to generate the
documentation for the C++ code. The documentation is generated by making the doc
target

    $ cd /the/build/directory
    $ make doc

## Usage

### Backend

Run the backend (server):

    $ bridge [-vv] [--config=config‐file]

The backend opens two sockets into two consequtive ports (by default 5555 and
5556 unless otherwise configured). The first one is used to receive commands
from the frontend and peers. The second one is for publishing events to the
clients.

The options are:

    config     A lua script used to configure the backend. There is a sample
               config file in sample/config.lua of the repository with comments.

The [sample config file](sample/config.lua) contains possible options for
different kinds of games with and without peers.

To increase logging level, -v and -vv flags can be used for INFO and DEBUG level
logging, respectively.

A single backend application can host multiple games identified by
UUID. Currently games with peers need to be configured at startup, but a client
can create peerless games where the single backend instance controls all
positions.

Note! The application does not yet correctly handle peers leaving and rejoining
the game. If a peer or a card server crashes, the session is lost.

### Frontend

Run the four frontend (client) instances

    $ bridgegui [--game UUID] [--create-game] endpoint

where `endpoint` is the control endpoint of the backend application. Run
`bridgegui --help` for the remaining options. Exactly one frontend must connect
to each position the backend controls. The backend automatically assigns
positions in order the frontends connect.

### Frontend display

Score sheet is displayed on the right. More rows are added to the sheet after
every deal.

Players and their cards are shown in the middle of the screen. The player whose
position is bolded has turn to call (during auction) or play a card to the trick
(during playing).

### Call

Bidding for the current deal is displayed on the left. Calls are made pushing
the buttons and the call sequence is shown in the table underneath. Enabled
buttons correspond to the allowed calls.

### Play

Cards for all the players are displayed in the middle area. During the playing
phase cards are played by clicking the card. Allowed cards are opaque and cards
that cannot be played to the current trick are slightly transparent.

## Card server

If [LibTMCG](http://www.nongnu.org/libtmcg/) is found in the system, the card
server is built in addition to the bridge application. Card server can be used
to execute secure mental card game protocol (ensuring that peers cannot know the
cards of the other peers except when all peers cooperate within the normal laws
of contract bridge). Small Python program used to test the card server is run as
part of the ctest suite.

Uncomment the necessary sections in the sample config file and run `bridgecs`
along with the bridge application.

    peer@example.com$ bridge --config=sample/config.lua &
    peer@example.com$ bridgecs tcp://127.0.0.1:5560 tcp://*:5565 &
    peer@example.com$ bridgegui tcp://localhost:5555

The card server binds one endpoint for communicating with its controlling bridge
backend, and one endpoint for communicating with its own peers. In the example
above, the local TCP port 5560 is bound for controlling the card server. Public
TCP port 5565 is bound for communicating with remote card server peers.

## Security

**Note! This feature is still experimental.**

The communication between nodes can be authenticated and encrypted using CURVE
mechanism implemented in the ZeroMQ library (http://curvezmq.org/).

To start the backend with CURVE support, load a configuration file containing
CURVE keys. The [sample config file](sample/config.lua) enables CURVE support
when the `BRIDGE_USE_CURVE` environment variable is set.

    $ export BRIDGE_USE_CURVE=1
    $ bridge --config=sample/config.lua

The GUI needs to configure the public key of the server. It can be extracted
from the server configuration script and saved to a file.

    $ bridgegui --server-key-file=server-key …rest of the args…

The card server acts both as server and client, and needs both keys

    $ export BRIDGE_USE_CURVE=1
    $ bridgecs --secret-key-file=secret-key --public-key-file=server-key       \
    >     …rest of the args…

The current implementation requires that a bridge backend and its card server
must share the same CURVE keypair.

The backend partially authenticates peers connecting to it by checking that only
peers with known public keys (those that are known to belong to peers taking
part in the game) are allowed to join a game. Connections from clients are not
authenticated.

Card server does not currently authenticate incoming connections.

All clients, peers and card servers authenticate outgoing connections as part of
the ZeroMQ CURVE mechanism.

Please see LibTMCG documentation for further information about its security
model and assumptions, in particular the honest‐but‐curious security model.

## TODO

Obviously the application is never complete. Because this is hobby project I do
to learn about network software — and because I’m an engineer and not a normal
person — the interesting network stuff comes first and the (in comparison)
boring UX stuff comes later. In approximate order of importance the next goals
for this project are:

- Proper support for authenticating clients, remote peers and card servers
- More user friendly installation and configuration of the application
- Persistent state for the backend (persistent sessions, keep records etc.)
- Nicer user interface and other usability oriented features (claiming tricks,
  canceling moves etc.)
- Peer discovery

## Copyright

Copyright © 2015–2019 Jaakko Moisio <jaakko@moisio.fi>

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.
